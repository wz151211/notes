#### 平均负载

平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就 是平均活跃进程数。

可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命 令看到的，处于 R 状态（Running 或 Runnable）的进程。

不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最 常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程（不可中断状态实际上是系统对进程和硬件设备的一种保护机制）

##### 平均负载为多少时合理

  平均负载最理想的情况是等于 CPU 个数。查看有多少个cpu可以使用命令top或 ` grep 'model name' /proc/cpuinfo | wc -l`。

查询系统平均负载命令用uptime

`$ uptime `

`02:34:03 当前时间`

`up 2 days , 20:14, 系统运行时间`

` 1 user, 正在登陆的用户数` 

` load average: 0.63, 0.83, 0.88 过去 1 分钟、5 分钟、15 分钟的平均负载`

假设我们在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说 明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698 % 的超载。

那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？

当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。一旦 负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。

##### 平均负载与 CPU 使用率

平均负载它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。

CPU 使用率，是单位时间内 CPU 繁忙情况的统计。

- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的。
- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高。
- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。

#### CPU 上下文切换

Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然， 这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它 们，造成多任务同时运行的错觉。而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要 系统事先帮它设置好 CPU 寄存器和程序计数器。

CPU 上下文切换，就是先 把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务 的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

根据任务的不同，CPU 的上下文切换就可以分为进程上下文切 换、线程上下文切换以及中断上下文切换

##### 进程上下文切换

Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。

​                                                              ![进程上下文切换](./images/进程上下文切换.png)

- 内核空间（Ring 0）具有最高权限，可以直接访问所有资源；
- 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用 陷入到内核中，才能访问这些特权资源。

换个角度看，也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空 间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。

从用户态到内核态的转变，需要通过系统调用来完成。CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄 存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运 行进程。所以，**一次系统调用的过程，其实是发生了两次 CPU 上下文切换**。

不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：

-  进程上下文切换，是指从一个进程切换到另一个进程运行。
- 而系统调用过程中一直是同一个进程在运行。

所以，系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中， CPU 的上下文切换还是无法避免的。

进程上下文切换跟系统调用又有什么区别呢？

 进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程 的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等 内核空间的状态。因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器 之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新 进程的虚拟内存和用户栈。

什么时候会切换进程上下文？

只有在进程调度的时候，才需要切换上下文。 Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程） 按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。

进程在什么时候才会被调度到 CPU 上运行呢？

1. 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片 再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正 在等待 CPU 的进程运行。
2. 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程 也会被挂起，并由系统调度其他进程运行。
3. 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
4. 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高 优先级进程来运行。
5. 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

##### 线程上下文切换

线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位。内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全 局变量等资源。

对于线程和进程，我们可以这么理解：

1. 当进程只有一个线程时，可以认为进程就等于线程。
2. 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上 下文切换时是不需要修改的。
3. 线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存 的。

线程的上下文切换其实就可以分为两种情况：

1.  前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文 切换是一样。
2. 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

##### 中断上下文切换

为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上 下文切换同时发生。

