---
typora-root-url: ./images
---

### InnoDB行格式

存放记录的方式叫做行格式或记录格式，InnoDB设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、 Dynamic 和 Compressed 行格式

#####  指定行格式的语法

​      我们可以在创建或修改表的语句中指定 行格式 ： 

​     CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称

​     ALTER TABLE 表名 ROW_FORMAT=行格式名称



#####  COMPACT行格式

​              一条完整的记录其实可以被分为 **记录的额外信息** 和 **记录的真实数据** 两部分

![](/../COMPACT行格式.png)

###### 变长字段长度列表

   变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。
因此变长字段的占用的存储空间为：**真正的数据内容+占用的字节数**

   在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长 字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序**存放

​    如何确定用1个还是2个字节来 表示真实数据占用的字节数？InnoDB 有它的一套规则，我们首先声明一下 W 、 M 和 L 的意思

1. 假设某个字符集中表示一个字符最多需要使用的字节数为 W ，也就是使用 SHOW CHARSET 语句的结果中的 Maxlen 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是 1 。
2.   对于变长类型 VARCHAR(M) 来说，这种类型表示能存储最多 M 个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是 M×W 。
3.  假设它实际存储的字符串占用的字节数是 L 。

确定用1个还是2个字节来 表示真实数据占用的字节数规则如下：

- 如果 M×W <= 255 ，那么使用1个字节来表示真正字符串占用的字节数。

  > ​       也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最 大字节数不大于255时，可以认为只使  用1个     字节来表示真正字符串占用的字节数。

- 如果 M×W > 255 ，则分为两种情况： 

​            如果 L <= 127 ，则用1个字节来表示真正字符串占用的字节数。

​            如果 L > 127 ，则用2个字节来表示真正字符串占用的字节数。

> ​        InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节 数大于255时，该怎么区分它正在读的某个        字节是一个单独的字段长度还是半个字段长度呢？ 设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那 该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0）， 如果该字节的第一个位为1，那该字节就是半个字段长度。

> ​     对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个 页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变 长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

**总结：如果该可变字段允许存储的最大字节数（ M×W ）超过255字节并且真实存储的字节数（ L ） 超过127字节，则使用2个字节，否则使用1个字节。**

**注意：**

1. **变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度 是不储存的**
2. **如果表中所有的列都不是变长的数据类型的话， 这一部分可省略**

###### NULL 值列表

为节省存储空间Compact 行格式把值为 NULL 的列统一管理起来，存储到 NULL 值列表中。

处理过程是这样的：

1. 首先统计表中允许存储 NULL 的列有哪些
2. 如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL 的列对应一个 二进制位，二进制位按照列的顺序**逆序**排列， 二进制位的值为 1 时，代表该列的值为 NULL ， 二进制位的值为 0 时，代表该列的值不为 NULL 。

3. MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节 的高位补 0（如果一个表中有9个允许为 NULL ，那这个记录的 NULL 值列表部分就需要2个字节来表示） 。

###### 记录头信息

记录头信息是由固定的 5 个字节组成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图

![](/../记录头信息-5972977.jpg)

| 名称         | 大小（单位：bit） | 描述                                                         |
| ------------ | ----------------- | ------------------------------------------------------------ |
| 预留位       | 1                 | 没有使用                                                     |
| 预留位       | 1                 | 没有使用                                                     |
| delete_mask  | 1                 | 标记该记录是否被删除                                         |
| min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| n_owned      | 4                 | 表示当前记录拥有的记录数                                     |
| heap_no      | 13                | 表示当前记录在记录堆的位置信息                               |
| record_type  | 3                 | 表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶子节点记录， 2 表示最小记录， 3 表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置                                     |



###### 记录的真实数据

一行数据除了存储真实数据外，MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），如下

| 列名                        | 是否必须 | 占用空间 | 描述                   |
| --------------------------- | -------- | -------- | ---------------------- |
| row_id（DB_ROW_ID）         | 否       | 6 字节   | 行ID，唯一标识一条记录 |
| transaction_id（DB_TRX_ID） | 是       | 6 字节   | 事务ID                 |
| roll_pointer（DB_ROLL_PTR） | 是       | 7字节    | 回滚指针               |

![](/../记录的真实数据.jpg)

 InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键。

###### CHAR(M)列的存储格式

   对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

​    变长字符集的 CHAR(M) 类型的列要求至少占用 M 个字节，而 VARCHAR(M) 却没有这个要 求。比方说对于使用 utf8 字符集的 CHAR(10) 的列来说，该列存储的数据字节长度的范围是10～30个字节。即 使我们向该列中存储一个空字符串也会占用 10 个字节，这是怕将来更新该列的值的字节长度大于原有值的字节 长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有 的记录空间成为所谓的碎片